---
layout: post
title:  "cve-2012-0158"
date:   2019-4-21
categories: 《漏洞战争》cve-2012-0158
excerpt: 
---

* content
{:toc}




# **cve-2012-0158**

## **简介**

被称为Office漏洞史上的经典案例，主要是由于Microsoft Windows通用控件中的MSCOMCTL.TreeView、MSCOMCTL.ListView2、MSCOMCTL.TreeView2、MSCOMCTL.ListView控件（MSCOMCTL.OCX）中存在栈溢出漏洞，导致可被用于执行任意代码

## **分析环境**

操作系统 Win7

漏洞软件 Microsoft Word 2007

## **漏洞分析**

我们先用metasploit生成样本，这次我和书中作者生成的不一样，书中作者生成的是崩溃式的样本可以直接定位到栈溢出代码附近，这次我生成的是一个完整的利用样本，可以弹出计算器。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2862or7e7j20xz0s5goy.jpg>)

如果是要崩溃式样本直接在这里set target 0然后exploit就可以了，获取计算器的则是

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g28657p0rxj20op06raav.jpg>)

拿到样本之后，在offic
2007的环境下运行以下，可以弹出计算器。接下来就是如何定位到漏洞位置的地方了，不像前面的崩溃式样本一样可以直接定位到漏洞附近，所以我们需要自己找。用winhex打开样本文件，查找一下有没有类似跳转的指令，试着找一下nop（0x90），还真的找到了，那它前面的就应该是跳板地址了。在windbg里面确认下

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g297fc87d0j20ns0q4tan.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g297gtbddoj20ja01x0sm.jpg>)

我们在这里下一个内存访问断点

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g297iki5g4j20l007igm1.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g297kxu69sj213h0kdgop.jpg>)

当前的esp应该就是shellcode的起始位置了，接下来我们来找漏洞。

这里有两种方式，一种是如果没有开启ASLR的话，就可以在jmp
esp命令所在的地址的栈地址下内存写入断点，重新载入之后就是漏洞的位置。我用的win7，开启了ASLR。所以只能栈回溯了，慢慢来找漏洞所在的位置，因为是覆盖返回地址到的jmp
esp，所以在栈空间漏洞所在的位置应该离jmp esp不远。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a725bpdpj20jr0jw0u9.jpg>)

Esp往前翻一翻，一直到82都是样本文件里面的，再前面就不是了，然后我们就一组一组的尝试。这里要注意分析前面函数的时候打开之后就不能再关闭了，因为开启了ASLR，重新载入地址就会改变，所以我们这里只能静态分析。四个四个的去分析它们所在的位置的函数，最后可以锁定是在这个位置发生了栈溢出，这种栈回溯的方式就比较麻烦，而且没有动态调试的配合找的位置也不一定是准确的。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a77iz27jj20m506gmxm.jpg>)

我们还是用内存写入断点来寻找，先关闭ASLR。在注册表加入HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlSession ManagerMemory Management。

我们找到27583c30所在的栈空间的位置。并在这里下内存写入断点

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a856eivmj20ij05y74n.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a87mqnzpj212l0jk0v2.jpg>)

然后F5往下运行，因为整个程序运行的过程中对这个地址不会只有一次写入，所以我们要F5很多次，直到最后一次使用。

我们打开word文件时就会卡住，因为这时候已经在往前面中断的地方写入

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a896k6r8j212v0mvtc9.jpg>)

继续F5，一直F5到计算器弹出，我们回上去找最后一次写入

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a8c7orssj21110p043j.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a8de22l7j213n0mr41u.jpg>)

看到了这个复制语句，找到它所在的函数，以及它所在的块是MSCOMCTL，这里就是漏洞点的位置

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a8e1zc1tj20jj0evwff.jpg>)

我们在ida找到它所在的位置，复制的长度为dwBytes

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a9p6pxr5j210h0m3jty.jpg>)

我们来找一下这个dwBytes长度是从哪里来的。

在IDA-VIEW选中这个函数然后在view-open subview-funcation call里可以查找到什么函数调用了这个函数

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a9r4va7xj20jo0cvab9.jpg>)

一个一个看过去，最后可以找到这个函数，因为只有这一个函数调用前面溢出函数的长度不是给定的。这里比较有意思的要长度大于8才可以进入这个函数，这里根据官方最后的结论是程序员的失误，实际应该是小于8才进入这个函数。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2a9tus0obj20kn0l7dhm.jpg>)

最后微软把这个修改来避免了栈溢出的问题。

Shellcode的利用就是覆盖了返回地址为jmp esp的地址，然后跳到esp执行

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g2abzpdzwwj21430nxn1h.jpg>)

## **漏洞修复**

把大于8改为了不等于8就发生返回。

## **参考链接**

《漏洞战争》

<https://www.anquanke.com/post/id/91643>

<https://bbs.pediy.com/thread-230001.htm>

<https://weiyiling.cn/one/cve_2012_0158_ms12-027>
