---
layout: post
title:  "Cve-2012-3569"
date:   2019-6-6
categories: 《漏洞战争》cve-2012-3569
excerpt: 
---

* content
{:toc}



# **cve-2012-3569**

## **漏洞介绍：**

VMware OVF
Tool是由VMware免费提供的一款支持虚拟的导入导出工具。该漏洞再解析OVF文件时存在格式化字符串漏洞，课可造成任意地址独写。

## **测试环境：**

操作系统：Win XP SP3

VMware OVF Tool：2.1.0-467744

## **漏洞分析：**

Poc在命令行打开。出现了错误，输出了一段字符串。点取消，进入od分析。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r92zhd5fj20mk0gyab2.jpg>)

看到当前eip为0x00000000，而且栈空间全部被破坏

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r96w140lj211y0nddht.jpg>)

可以看到前面的有一段字符Invalid
value，在od搜索一下字符串，先alt+e，然后点第一个，

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r9aq6qyhj20xq0gbgn8.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r9cvm3thj20rm0k275z.jpg>)

在这里下一个断点，重新载入。**这里要注意，因为VMware OVF
Tool在命令行打开是跟有参数的，而第一次的od重新载入是没有带参数的。所以要自己设定参数，在调试-参数设置

确定后重新载入就有了参数。**

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r9gbe4z8j20c405maac.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r9gtghlrj20fz03q3yk.jpg>)

F9运行到断点，往下f8一直运行，找到输出字符串的地方。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r9ibko0bj20u20fw763.jpg>)

F8了很久才到想看到的东西，在这个call下个断点，重新载入。往函数里走继续找出现字符串的地方。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r9p19moij20t10g1mzz.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r9rxke37j20um0l978e.jpg>)

下断点重新载入，继续。来到了这个位置，这里是一个c++的函数basic_ostream，看到这里也明白了，这个程序没用用printf来输出而是用了basic_ostream来作为输出函数。

<https://zh.cppreference.com/w/cpp/io/basic_ostream>

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3r9u0hvohj21160mpdlc.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rdgonywaj20r80jydi3.jpg>)

在ida里面找到这个位置，f5看看，可以看到，只有一个参数，也就是有格式化字符串的漏洞。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rdogbuyvj216y0m1ad8.jpg>)

来看一看poc的代码，可以看到大量的格式化字符出现以及最后的%hn写入。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rdtqohajj20tv0podhv.jpg>)

运行它来看看输出的结果。输出的应该是栈空间的数据。往basic_ostream这个函数里面继续深入，来看看这个数据是哪里来的。

来到这里，可以看到，当前的eax存的是格式化字符串数组，并且被压入栈中，继续进入

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rehfz71qj213p0n7dis.jpg>)

进入这个函数，看到这一段代码，eax被赋给了栈中的某一个地址，而这个地址的上方就是格式化字符串的位置。根据下面那张格式化字符串原理的图，eax上方的地址就是format，而eax就是第一个偏移，也就是说最后的输出会从这个地址开始。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rephu6jgj20sn0hm3zp.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3reqmi812j213y0n0771.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3reup9mbcj20g00mmag3.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3reu2x9ytj20ed0fjt9x.jpg>)

确实是从这里输出

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rewvm8lsj21360o9goi.jpg>)

再来看看，%hn修改了哪里。最后输出的是0x00000004。也就是它的下一行被修改了，修改成了0x00120345，最后4位被修改成0345，这个0345是哪来的呢？poc中一共有26个‘A’和98个‘%08x’，然后用的又是%hn，所以大小就是（98*4+26）*2=344+1=0x345。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rf2o9l8dj20xb0h3767.jpg>)

最后来找一下，程序是在哪里崩溃的。

在这里把ebp给了esp，ebp的地址就是前面覆写的，可以看到ebp的栈空间全为0，所以最后返回的时候造成了崩溃。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rh9xmkt8j20yw0m4di9.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rhm57c2vj20y50n2die.jpg>)

## **漏洞利用：**

打开作者的exp.ovf，一样的位置，最后还是输出0x00000004，所以还是覆盖了后面的地址。

可以看到被覆写为0x121000

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rfz861axj213x0ngq71.jpg>)

来看看0x121000的位置是什么，可以看到是shellcode的一部分，我们只要在下面构造rop对它的操作就可以控制eip，执行任意代码。剩下的只需要考虑绕过DEP和ASLR了。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rghut0uij21am0nvtd2.jpg>)

继续往下走，在这里把前面的地址弹给了ebp，下面的ret跳到了另一个地方，把ebp给了esp再弹出一个给ebp再返回，返回的是一个call
esp，完成了eip的控制。

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rgqgjtjzj210r0mz414.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rgt23eqoj21220lldi1.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rgw874ymj20xd0mcq56.jpg>)

![](<http://ww1.sinaimg.cn/large/7fb67c86gy1g3rgwmssugj20uk0733z7.jpg>)




## **参考链接：**
《漏洞战争》
